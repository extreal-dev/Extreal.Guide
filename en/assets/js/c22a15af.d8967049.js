"use strict";(self.webpackChunkextreal=self.webpackChunkextreal||[]).push([[7160],{2570:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>l,metadata:()=>s,toc:()=>p});var a=t(9668),i=(t(6540),t(5680)),r=t(7443);const l={sidebar_position:5},o="P2P using WebRTC",s={unversionedId:"integration/p2p.webrtc",id:"integration/p2p.webrtc",title:"P2P using WebRTC",description:"What for?",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/integration/p2p.webrtc.md",sourceDirName:"integration",slug:"/integration/p2p.webrtc",permalink:"/Extreal.Guide/en/next/integration/p2p.webrtc",draft:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Common for Web",permalink:"/Extreal.Guide/en/next/integration/web.common"},next:{title:"Chat using WebRTC",permalink:"/Extreal.Guide/en/next/integration/chat.webrtc"}},c={},p=[{value:"What for?",id:"what-for",level:2},{value:"Specification",id:"specification",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Unity",id:"unity",level:3},{value:"JavaScript",id:"javascript",level:3},{value:"Installation",id:"installation",level:2},{value:"Package",id:"package",level:3},{value:"Unity",id:"unity-1",level:4},{value:"npm",id:"npm",level:4},{value:"Dependencies",id:"dependencies",level:3},{value:"Unity",id:"unity-2",level:4},{value:"npm",id:"npm-1",level:4},{value:"Settings",id:"settings",level:3},{value:"Signaling server",id:"signaling-server",level:4},{value:"Application",id:"application",level:4},{value:"Usage",id:"usage",level:2},{value:"Establish a host/client P2P connection",id:"p2p-webrtc-host-client",level:3},{value:"Add processing to trigger P2P state",id:"add-processing-to-trigger-p2p-state",level:3},{value:"Add application-specific processing to Native(C#) P2P",id:"add-application-specific-processing-to-nativec-p2p",level:3},{value:"Add application-specific processing to WebGL(JavaScript) P2P",id:"add-application-specific-processing-to-webgljavascript-p2p",level:3},{value:"Make the signaling server redundant",id:"make-the-signaling-server-redundant",level:3}],g={toc:p},d="wrapper";function m(e){let{components:n,...t}=e;return(0,i.yg)(d,(0,a.A)({},g,t,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"p2p-using-webrtc"},"P2P using WebRTC"),(0,i.yg)("h2",{id:"what-for"},"What for?"),(0,i.yg)("p",null,"P2P(Peer to Peer) is a means of communicating in virtual spaces, etc., with the lowest possible cost."),(0,i.yg)("p",null,"P2P can be realized relatively easily by using WebRTC, but since P2P connection establishment is a similar processing, it is provided as a common feature.\nBy using this common feature, application-specific P2P can be realized by simply adding data channel and media stream processing."),(0,i.yg)("p",null,"This module provides base P2P features for Native(C#) and WebGL(JavaScript)."),(0,i.yg)("h2",{id:"specification"},"Specification"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"You can establish a host/client P2P connection."),(0,i.yg)("li",{parentName:"ul"},"You can add processing to trigger P2P state."),(0,i.yg)("li",{parentName:"ul"},"You can add application-specific processing to Native(C#) P2P."),(0,i.yg)("li",{parentName:"ul"},"You can add application-specific processing to WebGL(JavaScript) P2P"),(0,i.yg)("li",{parentName:"ul"},"You can make signaling servers redundant.")),(0,i.yg)("h2",{id:"architecture"},"Architecture"),(0,i.yg)("h3",{id:"unity"},"Unity"),(0,i.yg)(r.K,{chart:"classDiagram\n\n    PeerClientProvider ..> PeerClient\n    PeerClient <|-- NativePeerClient\n    PeerClient <|-- WebGLPeerClient\n    PeerClient ..> PeerConfig\n    PeerConfig <|-- WebGLPeerConfig\n\n    class PeerClientProvider {\n        +Provide(peerConfig)$ PeerClient\n    }\n    \n    class PeerClient {\n        <<abstract>>\n        +OnStarted IObservable\n        +OnConnectFailed IObservable\n        +OnDisconnected IObservable\n        +OnUserConnected IObservable\n        +OnUserDisconnected IObservable\n        +IsRunning bool\n        +StartHostAsync(name) void\n        +ListHostsAsync() List\n        +StartClientAsync(hostId) void\n        +Stop() void\n        +getSocketId() string\n    }\n    \n    class PeerConfig {\n        +SignalingUrl string\n        +SocketOptions SocketIOOptions\n        +IceServerUrls List\n    }\n\n    class NativePeerClient {\n    }\n    \n    class WebGLPeerClient {\n    }\n\n    class WebGLPeerConfig {\n        +WebGLSocketOptions WebGLSocketOptions\n    }",mdxType:"Mermaid"}),(0,i.yg)("h3",{id:"javascript"},"JavaScript"),(0,i.yg)(r.K,{chart:"classDiagram\n\n    WebGLPeerClient ..> WebGLHelper  \n    PeerClient <.. WebGLHelper  \n    PeerAdapter ..> PeerClient\n\n    class WebGLPeerClient {\n        <<C#>>\n    }\n    \n    class WebGLHelper {\n        <<C#>>\n    }\n\n    class PeerAdapter {\n        <<TypeScript>>\n        +adapt() void\n    }\n    \n    class PeerClient {\n        <<TypeScript>>\n        +role PeerRole\n        +hostId string\n        +addPcCreateHook(hook) void\n        +addPcCloseHook(hook) void\n        +startHost(name, handle) void\n        +listHosts(handle) void\n        +startClientAsync(hostId) void\n        +stop() void\n    }",mdxType:"Mermaid"}),(0,i.yg)("p",null,"In P2P, the application and the signaling server cooperate to establish a P2P connection.\nIn order to establish a P2P connection, this module provides a feature that assumes the following processing flow.\nWhen one user becomes a host and another user joins the host, a P2P connection is established with the host and the users already joined to the host."),(0,i.yg)(r.K,{chart:'sequenceDiagram\n    actor Host\n    participant Signaling\n    actor Client\n    actor ClientsAlreadyJoined\n    Host->>Signaling: create host\n    alt Succeeded\n        Signaling--\x3e>Host: 200 "Host have been created"\n    else Host already exists\n        Signaling--\x3e>Host: 409 "Host already exists"\n    end\n    Client->>Signaling: list hosts\n    Signaling--\x3e>Client: 200 host list or empty list\n    Client->>Signaling: message "join"\n    Signaling--\x3e>Host: message "join"\n    Host->>Signaling: message "offer"\n    Signaling--\x3e>Client: message "offer"\n    Client->>Signaling: message "answer" \n    Signaling--\x3e>Host: message "answer"\n    Host->>Signaling: message "done"\n    Signaling--\x3e>Client: message "done"\n    Host->>Signaling: message "call me"\n    Signaling--\x3e>ClientsAlreadyJoined: message "call me"\n    ClientsAlreadyJoined->>Signaling: message "offer"\n    Signaling--\x3e>Client: message "offer"\n    Client->>Signaling: followed by "answer" to "done" but omitted',mdxType:"Mermaid"}),(0,i.yg)("admonition",{type:"info"},(0,i.yg)("p",{parentName:"admonition"},"This module uses Vanilla ICE, which has simple logic, for WebRTC route information gathering.\nVanilla ICE waits for all the route information gathering to be completed, so it may take a long time (e.g., 40 seconds) depending on the network environment.\nSince there is a high possibility that a connection can be established without waiting for all the routing information to be gathered, this module provides a timeout for Vanilla ICE to stop route information gathering after a short period of time.\nThe default is 5 seconds. this timeout can be changed using PeerConfig.")),(0,i.yg)("h2",{id:"installation"},"Installation"),(0,i.yg)("h3",{id:"package"},"Package"),(0,i.yg)("h4",{id:"unity-1"},"Unity"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"https://github.com/extreal-dev/Extreal.Integration.P2P.WebRTC.git\n")),(0,i.yg)("h4",{id:"npm"},"npm"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"@extreal-dev/extreal.integration.p2p.webrtc\n")),(0,i.yg)("h3",{id:"dependencies"},"Dependencies"),(0,i.yg)("p",null,"This module uses the following packages."),(0,i.yg)("h4",{id:"unity-2"},"Unity"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"/Extreal.Guide/en/next/core/logging"},"Extreal.Core.Logging")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"/Extreal.Guide/en/next/core/common"},"Extreal.Core.Common")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"/Extreal.Guide/en/next/integration/web.common"},"Extreal.Integration.Web.Common")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://docs.unity3d.com/Packages/com.unity.collections@1.2/manual/index.html"},"Collections")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://docs.unity3d.com/Packages/com.unity.webrtc@3.0/manual/index.html"},"WebRTC")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://github.com/Cysharp/UniTask"},"UniTask")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://github.com/neuecc/UniRx"},"UniRx")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://learn.microsoft.com/ja-jp/dotnet/api/system.text.json"},"System.Text.Json")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://github.com/doghappy/socket.io-client-csharp"},"SocketIOClient"))),(0,i.yg)("h4",{id:"npm-1"},"npm"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.npmjs.com/package/@extreal-dev/extreal.integration.web.common"},"@extreal-dev/extreal.integration.web.common")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.npmjs.com/package/socket.io-client"},"socket.io-client"))),(0,i.yg)("h3",{id:"settings"},"Settings"),(0,i.yg)("h4",{id:"signaling-server"},"Signaling server"),(0,i.yg)("p",null,"Signaling server is provided by ",(0,i.yg)("a",{parentName:"p",href:"https://docs.docker.com/compose/"},"Docker Compose"),".\nPlease refer to ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/extreal-dev/Extreal.Integration.P2P.WebRTC/tree/main/SignalingServer~"},"README")," to prepare your signaling server."),(0,i.yg)("h4",{id:"application"},"Application"),(0,i.yg)("p",null,"Create a PeerClient using PeerClientProvider.\nSpecify the URL of the signaling server when creating the PeerClient."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'public class ClientControlScope : LifetimeScope\n{\n    protected override void Configure(IContainerBuilder builder)\n    {\n        var peerConfig = new PeerConfig("http://127.0.0.1:3010");\n        var peerClient = PeerClientProvider.Provide(peerConfig);\n        builder.RegisterComponent(peerClient);\n    }\n}\n')),(0,i.yg)("p",null,"If you want to use it with WebGL, initialize it further with JavaScript.\nCreate a PeerAdapter and call the adapt function."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-typescript"},'import { PeerAdapter } from "@extreal-dev/extreal.integration.p2p.webrtc";\n\nconst peerAdapter = new PeerAdapter();\npeerAdapter.adapt();\n')),(0,i.yg)("admonition",{type:"info"},(0,i.yg)("p",{parentName:"admonition"},"For a development environment using TypeScript, please refer to ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/extreal-dev/Extreal.Integration.P2P.WebRTC/tree/main/Samples~/MVS/WebGLScripts~"},"sample")," in this module.")),(0,i.yg)("h2",{id:"usage"},"Usage"),(0,i.yg)("h3",{id:"p2p-webrtc-host-client"},"Establish a host/client P2P connection"),(0,i.yg)("p",null,"This module provides host/client oriented features to establish a P2P connection.\nThese features are provided by PeerClient."),(0,i.yg)("p",null,"First, create a host by specifying a name.\nThe user who created it becomes the host.\nIf the name is duplicated, a HostNameAlreadyExistsException is thrown."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'await peerClient.StartHostAsync("host name");\n')),(0,i.yg)("p",null,"The client(user who wants to join a host) gets a list of hosts."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"var hosts = await peerClient.ListHostsAsync();\n")),(0,i.yg)("p",null,"A list of Hosts with their Id and Name is returned, and the client joins the Host using the Host's Id obtained here.\nThe client requests to join a host and establishes a P2P connection with the host and other clients that have already joined the host."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"await peerClient.StartClientAsync(hostId);\n")),(0,i.yg)("p",null,"If the host is shut down or the client leaves the host, the P2P connection is stopped."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"peerClient.Stop();\n")),(0,i.yg)("h3",{id:"add-processing-to-trigger-p2p-state"},"Add processing to trigger P2P state"),(0,i.yg)("p",null,"PeerClient has the following event notifications"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"OnStarted",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Timing: Immediately after the host or client starts",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Host",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Immediately after the host is created"))),(0,i.yg)("li",{parentName:"ul"},"Client",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Immediately after all of the following conditions are met",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},'Receives "done" from the host'),(0,i.yg)("li",{parentName:"ul"},"IceConnectionState becomes Connected or Completed"))))))),(0,i.yg)("li",{parentName:"ul"},"Type: IObservable"),(0,i.yg)("li",{parentName:"ul"},"Parameters: User's own Client ID"))),(0,i.yg)("li",{parentName:"ul"},"OnStartFailed",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Timing: Immediately after host or client failed to start",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"If the start processing times out, the start is assumed to have failed."),(0,i.yg)("li",{parentName:"ul"},"The default timeout is 15 seconds. The timeout can be changed using PeerConfig."))),(0,i.yg)("li",{parentName:"ul"},"Type: IObservable"),(0,i.yg)("li",{parentName:"ul"},"Parameters: None"))),(0,i.yg)("li",{parentName:"ul"},"OnConnectFailed",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Timing: Immediately after the host or client has failed to connect to the signaling server"),(0,i.yg)("li",{parentName:"ul"},"Type: IObservable"),(0,i.yg)("li",{parentName:"ul"},"Parameters: Reason for connection failure"))),(0,i.yg)("li",{parentName:"ul"},"OnDisconnected",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Timing: Immediately after a host or client connected to the signaling server is disconnected"),(0,i.yg)("li",{parentName:"ul"},"Type: IObservable"),(0,i.yg)("li",{parentName:"ul"},"Parameters: Reason for disconnection"))),(0,i.yg)("li",{parentName:"ul"},"OnUserConnecting",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Timing: Immediately before another user connects",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Connected users receive events from each other. Therefore, newly connected users will receive as many events as all users already connected."))),(0,i.yg)("li",{parentName:"ul"},"Type: IObservable"),(0,i.yg)("li",{parentName:"ul"},"Parameters: Client ID of the user to connect"))),(0,i.yg)("li",{parentName:"ul"},"OnUserDisconnecting",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Timing: Immediately before another user disconnects"),(0,i.yg)("li",{parentName:"ul"},"Type: IObservable"),(0,i.yg)("li",{parentName:"ul"},"Parameters: Client ID of the user to disconnect")))),(0,i.yg)("h3",{id:"add-application-specific-processing-to-nativec-p2p"},"Add application-specific processing to Native(C#) P2P"),(0,i.yg)("admonition",{type:"caution"},(0,i.yg)("p",{parentName:"admonition"},"Processing continues even if errors occur during Create/Close of PeerConnection.")),(0,i.yg)("p",null,"PeerClient has hooks that can add processing at the start and end of a P2P connection."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"peerClient.AddPcCreateHook((id, isOffer, rtcPeerConnection) =>\n{\n    // do something\n});\n\npeerClient.AddPcCloseHook((id) =>\n{\n    // do something\n});\n")),(0,i.yg)("p",null,"These hooks are used to add application-specific features to P2P by manipulating data channels and media streams.\nAn example implementation for creating a data channel is as follows."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'#if !UNITY_WEBGL || UNITY_EDITOR\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing Extreal.Core.Logging;\nusing Unity.WebRTC;\n\nnamespace Extreal.Integration.P2P.WebRTC.MVS.ClientControl\n{\n    public class NativeDataChannelClient : DataChannelClient\n    {\n        private static readonly ELogger Logger = LoggingManager.GetLogger(nameof(NativeDataChannelClient));\n\n        private static readonly string Label = "sample";\n\n        private readonly Dictionary<string, RTCDataChannel> dcDict;\n\n        public NativeDataChannelClient(NativePeerClient peerClient)\n        {\n            dcDict = new Dictionary<string, RTCDataChannel>();\n            peerClient.AddPcCreateHook(CreatePc);\n            peerClient.AddPcCloseHook(ClosePc);\n        }\n\n        private void CreatePc(string id, bool isOffer, RTCPeerConnection pc)\n        {\n            if (dcDict.ContainsKey(id))\n            {\n                return;\n            }\n\n            if (isOffer)\n            {\n                var dc = pc.CreateDataChannel(Label);\n                HandleDc(id, dc);\n            }\n            else\n            {\n                pc.OnDataChannel += (dc) => HandleDc(id, dc);\n            }\n        }\n\n        private void HandleDc(string id, RTCDataChannel dc)\n        {\n            if (dc.Label != Label)\n            {\n                return;\n            }\n\n            if (Logger.IsDebug())\n            {\n                Logger.LogDebug($"New DataChannel: id={id} label={dc.Label}");\n            }\n\n            dcDict.Add(id, dc);\n            dc.OnMessage = message => Logger.LogDebug(Encoding.UTF8.GetString(message));\n        }\n\n        private void ClosePc(string id)\n        {\n            if (!dcDict.TryGetValue(id, out var dc))\n            {\n                return;\n            }\n            dc.Close();\n            dcDict.Remove(id);\n        }\n\n        public override void Clear()\n        {\n            dcDict.Keys.ToList().ForEach(ClosePc);\n            dcDict.Clear();\n        }\n    }\n}\n#endif\n')),(0,i.yg)("h3",{id:"add-application-specific-processing-to-webgljavascript-p2p"},"Add application-specific processing to WebGL(JavaScript) P2P"),(0,i.yg)("admonition",{type:"caution"},(0,i.yg)("p",{parentName:"admonition"},"Processing continues even if errors occur during Create/Close of PeerConnection.")),(0,i.yg)("p",null,"WebGL(JavaScript) is a bit more extensive than Native(C#) because it requires C# and JavaScript to work together.\nThe mechanism is the same as Native(C#), using hooks to add application-specific processing to P2P."),(0,i.yg)("p",null,"An example implementation for creating a data channel is shown below.\nThe major difference is that the PeerClient is obtained from the PeerClientProvider function."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-typescript"},'import { PeerClientProvider } from "@extreal-dev/extreal.integration.p2p.webrtc";\n\nclass DataChannelClient {\n    private readonly label: string = "sample";\n    private readonly isDebug: boolean;\n    private readonly dcMap: Map<string, RTCDataChannel>;\n    private readonly getPeerClient: PeerClientProvider;\n\n    constructor(getPeerClient: PeerClientProvider) {\n        this.isDebug = true;\n        this.dcMap = new Map();\n        this.getPeerClient = getPeerClient;\n        this.getPeerClient().addPcCreateHook(this.createPc);\n        this.getPeerClient().addPcCloseHook(this.closePc);\n    }\n\n    private createPc = (id: string, isOffer: boolean, pc: RTCPeerConnection) => {\n        if (this.dcMap.has(id)) {\n            return;\n        }\n\n        if (isOffer) {\n            const dc = pc.createDataChannel(this.label);\n            this.handleDc(id, dc);\n        } else {\n            pc.addEventListener("datachannel", (event) => this.handleDc(id, event.channel));\n        }\n    };\n\n    private handleDc = (id: string, dc: RTCDataChannel) => {\n        if (dc.label !== this.label) {\n            return;\n        }\n\n        if (this.isDebug) {\n            console.log(`New DataChannel: id=${id} label=${dc.label}`);\n        }\n\n        this.dcMap.set(id, dc);\n    };\n\n    private closePc = (id: string) => {\n        const dc = this.dcMap.get(id);\n        if (!dc) {\n            return;\n        }\n        dc.close();\n        this.dcMap.delete(id);\n    };\n\n    public clear = () => {\n        [...this.dcMap.keys()].forEach(this.closePc);\n        this.dcMap.clear();\n    };\n}\n\nexport { DataChannelClient };\n')),(0,i.yg)("p",null,"PeerClientProvider is provided by PeerAdapter, which appeared in ",(0,i.yg)("a",{parentName:"p",href:"#settings"},"Settings"),".\nPeerAdapter holds PeerClient internally and defines the interaction between C# and JavaScript."),(0,i.yg)("p",null,"To do P2P with WebGL, first create a PeerAdapter and call its adapt function.\nThen, use the getPeerClient function of the PeerAdapter to add application-specific processing like the DataChannelClient described earlier."),(0,i.yg)("p",null,"The timing of calling application-specific processing is important here.\nBe careful not to initialize the processing added by the application (in this case, DataChannelClient) before PeerClient in C#.\nThe C# PeerClient is initialized at the timing when the Provide method of PeerClientProvider is called."),(0,i.yg)("p",null,"Use ",(0,i.yg)("a",{parentName:"p",href:"/Extreal.Guide/en/next/integration/web.common"},"Web.Common")," to control the timing of the call from C#."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-typescript"},'import { addAction } from "@extreal-dev/extreal.integration.web.common";\nimport { PeerAdapter } from "@extreal-dev/extreal.integration.p2p.webrtc";\nimport { DataChannelClient } from "./DataChannelClient";\n\nconst peerAdapter = new PeerAdapter();\npeerAdapter.adapt();\n\nlet dataChannelClient: DataChannelClient;\naddAction("start", () => dataChannelClient = new DataChannelClient(peerAdapter.getPeerClient));\naddAction("clear", () => dataChannelClient.clear);\n')),(0,i.yg)("p",null,"Create a C# caller.\nUse WebGLHelper in ",(0,i.yg)("a",{parentName:"p",href:"/Extreal.Guide/en/next/integration/web.common"},"Web.Common"),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'using Extreal.Integration.Web.Common;\n\nnamespace Extreal.Integration.P2P.WebRTC.MVS.ClientControl\n{\n    public class WebGLDataChannelClient : DataChannelClient\n    {\n        public WebGLDataChannelClient() => WebGLHelper.CallAction("start");\n\n        public override void Clear() => WebGLHelper.CallAction("clear");\n    }\n}\n')),(0,i.yg)("h3",{id:"make-the-signaling-server-redundant"},"Make the signaling server redundant"),(0,i.yg)("p",null,(0,i.yg)("a",{parentName:"p",href:"https://socket.io/"},"Socket.IO")," is used for the signaling server.\nSticky sessions are recommended when using multiple Socket.IO servers for redundancy.\nSee ",(0,i.yg)("a",{parentName:"p",href:"https://socket.io/docs/v4/using-multiple-nodes/"},"Using multiple nodes")," for details."),(0,i.yg)("p",null,"To enable sticky sessions when used with WebGL, additional configuration is required when creating the PeerClient.\nIt is possible to enable sticky sessions using WebGLSocketOptions."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'public class ClientControlScope : LifetimeScope\n{\n    protected override void Configure(IContainerBuilder builder)\n    {\n        var peerConfig = new PeerConfig("http://127.0.0.1:3010");\n        var webGLPeerConfig = new WebGLPeerConfig(\n            peerConfig,\n            new WebGLSocketOptions(withCredentials: true)\n        );\n        var peerClient = PeerClientProvider.Provide(webGLPeerConfig);\n        builder.RegisterComponent(peerClient);\n    }\n}\n')),(0,i.yg)("admonition",{type:"info"},(0,i.yg)("p",{parentName:"admonition"},"When using with C#, no settings are necessary.")))}m.isMDXComponent=!0}}]);