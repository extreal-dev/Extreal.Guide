"use strict";(self.webpackChunkextreal=self.webpackChunkextreal||[]).push([[3576],{1792:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var t=i(7624),r=i(5788);const a={sidebar_position:5},s="P2P using WebRTC",l={id:"integration/p2p.webrtc",title:"P2P using WebRTC",description:"What for?",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/integration/p2p.webrtc.md",sourceDirName:"integration",slug:"/integration/p2p.webrtc",permalink:"/Extreal.Guide/en/next/integration/p2p.webrtc",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Common for Web",permalink:"/Extreal.Guide/en/next/integration/web.common"},next:{title:"Chat using WebRTC",permalink:"/Extreal.Guide/en/next/integration/chat.webrtc"}},o={},c=[{value:"What for?",id:"what-for",level:2},{value:"Specification",id:"specification",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Unity",id:"unity",level:3},{value:"JavaScript",id:"javascript",level:3},{value:"Installation",id:"installation",level:2},{value:"Package",id:"package",level:3},{value:"Unity",id:"unity-1",level:4},{value:"npm",id:"npm",level:4},{value:"Dependencies",id:"dependencies",level:3},{value:"Unity",id:"unity-2",level:4},{value:"npm",id:"npm-1",level:4},{value:"Settings",id:"settings",level:3},{value:"Signaling server",id:"signaling-server",level:4},{value:"Application",id:"application",level:4},{value:"Usage",id:"usage",level:2},{value:"Establish a host/client P2P connection",id:"p2p-webrtc-host-client",level:3},{value:"Add processing to trigger P2P state",id:"add-processing-to-trigger-p2p-state",level:3},{value:"Add application-specific processing to Native(C#) P2P",id:"add-application-specific-processing-to-nativec-p2p",level:3},{value:"Add application-specific processing to WebGL(JavaScript) P2P",id:"add-application-specific-processing-to-webgljavascript-p2p",level:3},{value:"Make the signaling server redundant",id:"make-the-signaling-server-redundant",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",mermaid:"mermaid",p:"p",pre:"pre",ul:"ul",...(0,r.MN)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"p2p-using-webrtc",children:"P2P using WebRTC"}),"\n",(0,t.jsx)(n.h2,{id:"what-for",children:"What for?"}),"\n",(0,t.jsx)(n.p,{children:"P2P(Peer to Peer) is a means of communicating in virtual spaces, etc., with the lowest possible cost."}),"\n",(0,t.jsx)(n.p,{children:"P2P can be realized relatively easily by using WebRTC, but since P2P connection establishment is a similar processing, it is provided as a common feature.\nBy using this common feature, application-specific P2P can be realized by simply adding data channel and media stream processing."}),"\n",(0,t.jsx)(n.p,{children:"This module provides base P2P features for Native(C#) and WebGL(JavaScript)."}),"\n",(0,t.jsx)(n.h2,{id:"specification",children:"Specification"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"You can establish a host/client P2P connection."}),"\n",(0,t.jsx)(n.li,{children:"You can add processing to trigger P2P state."}),"\n",(0,t.jsx)(n.li,{children:"You can add application-specific processing to Native(C#) P2P."}),"\n",(0,t.jsx)(n.li,{children:"You can add application-specific processing to WebGL(JavaScript) P2P"}),"\n",(0,t.jsx)(n.li,{children:"You can make signaling servers redundant."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,t.jsx)(n.h3,{id:"unity",children:"Unity"}),"\n",(0,t.jsx)(n.mermaid,{chart:"classDiagram\n\n    PeerClientProvider ..> PeerClient\n    PeerClient <|-- NativePeerClient\n    PeerClient <|-- WebGLPeerClient\n    PeerClient ..> PeerConfig\n    PeerConfig <|-- WebGLPeerConfig\n\n    class PeerClientProvider {\n        +Provide(peerConfig)$ PeerClient\n    }\n    \n    class PeerClient {\n        <<abstract>>\n        +OnStarted IObservable\n        +OnConnectFailed IObservable\n        +OnDisconnected IObservable\n        +OnUserConnected IObservable\n        +OnUserDisconnected IObservable\n        +IsRunning bool\n        +StartHostAsync(name) void\n        +ListHostsAsync() List\n        +StartClientAsync(hostId) void\n        +Stop() void\n        +getSocketId() string\n    }\n    \n    class PeerConfig {\n        +SignalingUrl string\n        +SocketOptions SocketIOOptions\n        +IceServerUrls List\n    }\n\n    class NativePeerClient {\n    }\n    \n    class WebGLPeerClient {\n    }\n\n    class WebGLPeerConfig {\n        +WebGLSocketOptions WebGLSocketOptions\n    }"}),"\n",(0,t.jsx)(n.h3,{id:"javascript",children:"JavaScript"}),"\n",(0,t.jsx)(n.mermaid,{chart:"classDiagram\n\n    WebGLPeerClient ..> WebGLHelper  \n    PeerClient <.. WebGLHelper  \n    PeerAdapter ..> PeerClient\n\n    class WebGLPeerClient {\n        <<C#>>\n    }\n    \n    class WebGLHelper {\n        <<C#>>\n    }\n\n    class PeerAdapter {\n        <<TypeScript>>\n        +adapt() void\n    }\n    \n    class PeerClient {\n        <<TypeScript>>\n        +role PeerRole\n        +hostId string\n        +addPcCreateHook(hook) void\n        +addPcCloseHook(hook) void\n        +startHost(name, handle) void\n        +listHosts(handle) void\n        +startClientAsync(hostId) void\n        +stop() void\n    }"}),"\n",(0,t.jsx)(n.p,{children:"In P2P, the application and the signaling server cooperate to establish a P2P connection.\nIn order to establish a P2P connection, this module provides a feature that assumes the following processing flow.\nWhen one user becomes a host and another user joins the host, a P2P connection is established with the host and the users already joined to the host."}),"\n",(0,t.jsx)(n.mermaid,{chart:'sequenceDiagram\n    actor Host\n    participant Signaling\n    actor Client\n    actor ClientsAlreadyJoined\n    Host->>Signaling: create host\n    alt Succeeded\n        Signaling--\x3e>Host: 200 "Host have been created"\n    else Host already exists\n        Signaling--\x3e>Host: 409 "Host already exists"\n    end\n    Client->>Signaling: list hosts\n    Signaling--\x3e>Client: 200 host list or empty list\n    Client->>Signaling: message "join"\n    Signaling--\x3e>Host: message "join"\n    Host->>Signaling: message "offer"\n    Signaling--\x3e>Client: message "offer"\n    Client->>Signaling: message "answer" \n    Signaling--\x3e>Host: message "answer"\n    Host->>Signaling: message "done"\n    Signaling--\x3e>Client: message "done"\n    Host->>Signaling: message "call me"\n    Signaling--\x3e>ClientsAlreadyJoined: message "call me"\n    ClientsAlreadyJoined->>Signaling: message "offer"\n    Signaling--\x3e>Client: message "offer"\n    Client->>Signaling: followed by "answer" to "done" but omitted'}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:"This module uses Vanilla ICE, which has simple logic, for WebRTC route information gathering.\nVanilla ICE waits for all the route information gathering to be completed, so it may take a long time (e.g., 40 seconds) depending on the network environment.\nSince there is a high possibility that a connection can be established without waiting for all the routing information to be gathered, this module provides a timeout for Vanilla ICE to stop route information gathering after a short period of time.\nThe default is 5 seconds. this timeout can be changed using PeerConfig."})}),"\n",(0,t.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,t.jsx)(n.h3,{id:"package",children:"Package"}),"\n",(0,t.jsx)(n.h4,{id:"unity-1",children:"Unity"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"https://github.com/extreal-dev/Extreal.Integration.P2P.WebRTC.git\n"})}),"\n",(0,t.jsx)(n.h4,{id:"npm",children:"npm"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"@extreal-dev/extreal.integration.p2p.webrtc\n"})}),"\n",(0,t.jsx)(n.h3,{id:"dependencies",children:"Dependencies"}),"\n",(0,t.jsx)(n.p,{children:"This module uses the following packages."}),"\n",(0,t.jsx)(n.h4,{id:"unity-2",children:"Unity"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/Extreal.Guide/en/next/core/logging",children:"Extreal.Core.Logging"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/Extreal.Guide/en/next/core/common",children:"Extreal.Core.Common"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/Extreal.Guide/en/next/integration/web.common",children:"Extreal.Integration.Web.Common"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://docs.unity3d.com/Packages/com.unity.collections@1.2/manual/index.html",children:"Collections"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://docs.unity3d.com/Packages/com.unity.webrtc@3.0/manual/index.html",children:"WebRTC"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/Cysharp/UniTask",children:"UniTask"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/neuecc/UniRx",children:"UniRx"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://learn.microsoft.com/ja-jp/dotnet/api/system.text.json",children:"System.Text.Json"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/doghappy/socket.io-client-csharp",children:"SocketIOClient"})}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"npm-1",children:"npm"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://www.npmjs.com/package/@extreal-dev/extreal.integration.web.common",children:"@extreal-dev/extreal.integration.web.common"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://www.npmjs.com/package/socket.io-client",children:"socket.io-client"})}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"settings",children:"Settings"}),"\n",(0,t.jsx)(n.h4,{id:"signaling-server",children:"Signaling server"}),"\n",(0,t.jsxs)(n.p,{children:["Signaling server is provided by ",(0,t.jsx)(n.a,{href:"https://docs.docker.com/compose/",children:"Docker Compose"}),".\nPlease refer to ",(0,t.jsx)(n.a,{href:"https://github.com/extreal-dev/Extreal.Integration.P2P.WebRTC/tree/main/SignalingServer~",children:"README"})," to prepare your signaling server."]}),"\n",(0,t.jsx)(n.h4,{id:"application",children:"Application"}),"\n",(0,t.jsx)(n.p,{children:"Create a PeerClient using PeerClientProvider.\nSpecify the URL of the signaling server when creating the PeerClient."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class ClientControlScope : LifetimeScope\n{\n    protected override void Configure(IContainerBuilder builder)\n    {\n        var peerConfig = new PeerConfig("http://127.0.0.1:3010");\n        var peerClient = PeerClientProvider.Provide(peerConfig);\n        builder.RegisterComponent(peerClient);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"If you want to use it with WebGL, initialize it further with JavaScript.\nCreate a PeerAdapter and call the adapt function."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { PeerAdapter } from "@extreal-dev/extreal.integration.p2p.webrtc";\n\nconst peerAdapter = new PeerAdapter();\npeerAdapter.adapt();\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["For a development environment using TypeScript, please refer to ",(0,t.jsx)(n.a,{href:"https://github.com/extreal-dev/Extreal.Integration.P2P.WebRTC/tree/main/Samples~/MVS/WebGLScripts~",children:"sample"})," in this module."]})}),"\n",(0,t.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,t.jsx)(n.h3,{id:"p2p-webrtc-host-client",children:"Establish a host/client P2P connection"}),"\n",(0,t.jsx)(n.p,{children:"This module provides host/client oriented features to establish a P2P connection.\nThese features are provided by PeerClient."}),"\n",(0,t.jsx)(n.p,{children:"First, create a host by specifying a name.\nThe user who created it becomes the host.\nIf the name is duplicated, a HostNameAlreadyExistsException is thrown."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'await peerClient.StartHostAsync("host name");\n'})}),"\n",(0,t.jsx)(n.p,{children:"The client(user who wants to join a host) gets a list of hosts."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"var hosts = await peerClient.ListHostsAsync();\n"})}),"\n",(0,t.jsx)(n.p,{children:"A list of Hosts with their Id and Name is returned, and the client joins the Host using the Host's Id obtained here.\nThe client requests to join a host and establishes a P2P connection with the host and other clients that have already joined the host."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"await peerClient.StartClientAsync(hostId);\n"})}),"\n",(0,t.jsx)(n.p,{children:"If the host is shut down or the client leaves the host, the P2P connection is stopped."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"peerClient.Stop();\n"})}),"\n",(0,t.jsx)(n.h3,{id:"add-processing-to-trigger-p2p-state",children:"Add processing to trigger P2P state"}),"\n",(0,t.jsx)(n.p,{children:"PeerClient has the following event notifications"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["OnStarted","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Timing: Immediately after the host or client starts","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Host","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Immediately after the host is created"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Client","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Immediately after all of the following conditions are met","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:'Receives "done" from the host'}),"\n",(0,t.jsx)(n.li,{children:"IceConnectionState becomes Connected or Completed"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Type: IObservable"}),"\n",(0,t.jsx)(n.li,{children:"Parameters: User's own Client ID"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["OnStartFailed","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Timing: Immediately after host or client failed to start","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If the start processing times out, the start is assumed to have failed."}),"\n",(0,t.jsx)(n.li,{children:"The default timeout is 15 seconds. The timeout can be changed using PeerConfig."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Type: IObservable"}),"\n",(0,t.jsx)(n.li,{children:"Parameters: None"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["OnConnectFailed","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Timing: Immediately after the host or client has failed to connect to the signaling server"}),"\n",(0,t.jsx)(n.li,{children:"Type: IObservable"}),"\n",(0,t.jsx)(n.li,{children:"Parameters: Reason for connection failure"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["OnDisconnected","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Timing: Immediately after a host or client connected to the signaling server is disconnected"}),"\n",(0,t.jsx)(n.li,{children:"Type: IObservable"}),"\n",(0,t.jsx)(n.li,{children:"Parameters: Reason for disconnection"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["OnUserConnecting","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Timing: Immediately before another user connects","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Connected users receive events from each other. Therefore, newly connected users will receive as many events as all users already connected."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Type: IObservable"}),"\n",(0,t.jsx)(n.li,{children:"Parameters: Client ID of the user to connect"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["OnUserDisconnecting","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Timing: Immediately before another user disconnects"}),"\n",(0,t.jsx)(n.li,{children:"Type: IObservable"}),"\n",(0,t.jsx)(n.li,{children:"Parameters: Client ID of the user to disconnect"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"add-application-specific-processing-to-nativec-p2p",children:"Add application-specific processing to Native(C#) P2P"}),"\n",(0,t.jsx)(n.admonition,{type:"caution",children:(0,t.jsx)(n.p,{children:"Processing continues even if errors occur during Create/Close of PeerConnection."})}),"\n",(0,t.jsx)(n.p,{children:"PeerClient has hooks that can add processing at the start and end of a P2P connection."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"peerClient.AddPcCreateHook((id, isOffer, rtcPeerConnection) =>\n{\n    // do something\n});\n\npeerClient.AddPcCloseHook((id) =>\n{\n    // do something\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"These hooks are used to add application-specific features to P2P by manipulating data channels and media streams.\nAn example implementation for creating a data channel is as follows."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'#if !UNITY_WEBGL || UNITY_EDITOR\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing Extreal.Core.Logging;\nusing Unity.WebRTC;\n\nnamespace Extreal.Integration.P2P.WebRTC.MVS.ClientControl\n{\n    public class NativeDataChannelClient : DataChannelClient\n    {\n        private static readonly ELogger Logger = LoggingManager.GetLogger(nameof(NativeDataChannelClient));\n\n        private static readonly string Label = "sample";\n\n        private readonly Dictionary<string, RTCDataChannel> dcDict;\n\n        public NativeDataChannelClient(NativePeerClient peerClient)\n        {\n            dcDict = new Dictionary<string, RTCDataChannel>();\n            peerClient.AddPcCreateHook(CreatePc);\n            peerClient.AddPcCloseHook(ClosePc);\n        }\n\n        private void CreatePc(string id, bool isOffer, RTCPeerConnection pc)\n        {\n            if (dcDict.ContainsKey(id))\n            {\n                return;\n            }\n\n            if (isOffer)\n            {\n                var dc = pc.CreateDataChannel(Label);\n                HandleDc(id, dc);\n            }\n            else\n            {\n                pc.OnDataChannel += (dc) => HandleDc(id, dc);\n            }\n        }\n\n        private void HandleDc(string id, RTCDataChannel dc)\n        {\n            if (dc.Label != Label)\n            {\n                return;\n            }\n\n            if (Logger.IsDebug())\n            {\n                Logger.LogDebug($"New DataChannel: id={id} label={dc.Label}");\n            }\n\n            dcDict.Add(id, dc);\n            dc.OnMessage = message => Logger.LogDebug(Encoding.UTF8.GetString(message));\n        }\n\n        private void ClosePc(string id)\n        {\n            if (!dcDict.TryGetValue(id, out var dc))\n            {\n                return;\n            }\n            dc.Close();\n            dcDict.Remove(id);\n        }\n\n        public override void Clear()\n        {\n            dcDict.Keys.ToList().ForEach(ClosePc);\n            dcDict.Clear();\n        }\n    }\n}\n#endif\n'})}),"\n",(0,t.jsx)(n.h3,{id:"add-application-specific-processing-to-webgljavascript-p2p",children:"Add application-specific processing to WebGL(JavaScript) P2P"}),"\n",(0,t.jsx)(n.admonition,{type:"caution",children:(0,t.jsx)(n.p,{children:"Processing continues even if errors occur during Create/Close of PeerConnection."})}),"\n",(0,t.jsx)(n.p,{children:"WebGL(JavaScript) is a bit more extensive than Native(C#) because it requires C# and JavaScript to work together.\nThe mechanism is the same as Native(C#), using hooks to add application-specific processing to P2P."}),"\n",(0,t.jsx)(n.p,{children:"An example implementation for creating a data channel is shown below.\nThe major difference is that the PeerClient is obtained from the PeerClientProvider function."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { PeerClientProvider } from "@extreal-dev/extreal.integration.p2p.webrtc";\n\nclass DataChannelClient {\n    private readonly label: string = "sample";\n    private readonly isDebug: boolean;\n    private readonly dcMap: Map<string, RTCDataChannel>;\n    private readonly getPeerClient: PeerClientProvider;\n\n    constructor(getPeerClient: PeerClientProvider) {\n        this.isDebug = true;\n        this.dcMap = new Map();\n        this.getPeerClient = getPeerClient;\n        this.getPeerClient().addPcCreateHook(this.createPc);\n        this.getPeerClient().addPcCloseHook(this.closePc);\n    }\n\n    private createPc = (id: string, isOffer: boolean, pc: RTCPeerConnection) => {\n        if (this.dcMap.has(id)) {\n            return;\n        }\n\n        if (isOffer) {\n            const dc = pc.createDataChannel(this.label);\n            this.handleDc(id, dc);\n        } else {\n            pc.addEventListener("datachannel", (event) => this.handleDc(id, event.channel));\n        }\n    };\n\n    private handleDc = (id: string, dc: RTCDataChannel) => {\n        if (dc.label !== this.label) {\n            return;\n        }\n\n        if (this.isDebug) {\n            console.log(`New DataChannel: id=${id} label=${dc.label}`);\n        }\n\n        this.dcMap.set(id, dc);\n    };\n\n    private closePc = (id: string) => {\n        const dc = this.dcMap.get(id);\n        if (!dc) {\n            return;\n        }\n        dc.close();\n        this.dcMap.delete(id);\n    };\n\n    public clear = () => {\n        [...this.dcMap.keys()].forEach(this.closePc);\n        this.dcMap.clear();\n    };\n}\n\nexport { DataChannelClient };\n'})}),"\n",(0,t.jsxs)(n.p,{children:["PeerClientProvider is provided by PeerAdapter, which appeared in ",(0,t.jsx)(n.a,{href:"#settings",children:"Settings"}),".\nPeerAdapter holds PeerClient internally and defines the interaction between C# and JavaScript."]}),"\n",(0,t.jsx)(n.p,{children:"To do P2P with WebGL, first create a PeerAdapter and call its adapt function.\nThen, use the getPeerClient function of the PeerAdapter to add application-specific processing like the DataChannelClient described earlier."}),"\n",(0,t.jsx)(n.p,{children:"The timing of calling application-specific processing is important here.\nBe careful not to initialize the processing added by the application (in this case, DataChannelClient) before PeerClient in C#.\nThe C# PeerClient is initialized at the timing when the Provide method of PeerClientProvider is called."}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.a,{href:"/Extreal.Guide/en/next/integration/web.common",children:"Web.Common"})," to control the timing of the call from C#."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { addAction } from "@extreal-dev/extreal.integration.web.common";\nimport { PeerAdapter } from "@extreal-dev/extreal.integration.p2p.webrtc";\nimport { DataChannelClient } from "./DataChannelClient";\n\nconst peerAdapter = new PeerAdapter();\npeerAdapter.adapt();\n\nlet dataChannelClient: DataChannelClient;\naddAction("start", () => dataChannelClient = new DataChannelClient(peerAdapter.getPeerClient));\naddAction("clear", () => dataChannelClient.clear);\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Create a C# caller.\nUse WebGLHelper in ",(0,t.jsx)(n.a,{href:"/Extreal.Guide/en/next/integration/web.common",children:"Web.Common"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using Extreal.Integration.Web.Common;\n\nnamespace Extreal.Integration.P2P.WebRTC.MVS.ClientControl\n{\n    public class WebGLDataChannelClient : DataChannelClient\n    {\n        public WebGLDataChannelClient() => WebGLHelper.CallAction("start");\n\n        public override void Clear() => WebGLHelper.CallAction("clear");\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"make-the-signaling-server-redundant",children:"Make the signaling server redundant"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://socket.io/",children:"Socket.IO"})," is used for the signaling server.\nSticky sessions are recommended when using multiple Socket.IO servers for redundancy.\nSee ",(0,t.jsx)(n.a,{href:"https://socket.io/docs/v4/using-multiple-nodes/",children:"Using multiple nodes"})," for details."]}),"\n",(0,t.jsx)(n.p,{children:"To enable sticky sessions when used with WebGL, additional configuration is required when creating the PeerClient.\nIt is possible to enable sticky sessions using WebGLSocketOptions."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class ClientControlScope : LifetimeScope\n{\n    protected override void Configure(IContainerBuilder builder)\n    {\n        var peerConfig = new PeerConfig("http://127.0.0.1:3010");\n        var webGLPeerConfig = new WebGLPeerConfig(\n            peerConfig,\n            new WebGLSocketOptions(withCredentials: true)\n        );\n        var peerClient = PeerClientProvider.Provide(webGLPeerConfig);\n        builder.RegisterComponent(peerClient);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:"When using with C#, no settings are necessary."})})]})}function h(e={}){const{wrapper:n}={...(0,r.MN)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},5788:(e,n,i)=>{i.d(n,{MN:()=>c});var t=i(1504);function r(e,n,i){return n in e?Object.defineProperty(e,n,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[n]=i,e}function a(e,n){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),i.push.apply(i,t)}return i}function s(e){for(var n=1;n<arguments.length;n++){var i=null!=arguments[n]?arguments[n]:{};n%2?a(Object(i),!0).forEach((function(n){r(e,n,i[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):a(Object(i)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(i,n))}))}return e}function l(e,n){if(null==e)return{};var i,t,r=function(e,n){if(null==e)return{};var i,t,r={},a=Object.keys(e);for(t=0;t<a.length;t++)i=a[t],n.indexOf(i)>=0||(r[i]=e[i]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)i=a[t],n.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(r[i]=e[i])}return r}var o=t.createContext({}),c=function(e){var n=t.useContext(o),i=n;return e&&(i="function"==typeof e?e(n):s(s({},n),e)),i},d={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},h=t.forwardRef((function(e,n){var i=e.components,r=e.mdxType,a=e.originalType,o=e.parentName,h=l(e,["components","mdxType","originalType","parentName"]),p=c(i),g=r,u=p["".concat(o,".").concat(g)]||p[g]||d[g]||a;return i?t.createElement(u,s(s({ref:n},h),{},{components:i})):t.createElement(u,s({ref:n},h))}));h.displayName="MDXCreateElement"}}]);